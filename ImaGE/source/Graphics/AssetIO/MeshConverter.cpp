#include "pch.h"
#ifndef IMGUI_DISABLE
#include "MeshConverter.h"
#include <assimp/Importer.hpp>      // C++ importer interface
#include <assimp/scene.h>           // Output data structure
#include <assimp/postprocess.h>     // Post processing flags

namespace {
  glm::vec2 ToGLMVec2(aiVector3D const& vec) { return { vec.x, vec.y }; }
  glm::vec3 ToGLMVec3(aiVector3D const& vec) { return { vec.x, vec.y, vec.z }; }
  glm::vec4 ToGLMVec4(aiColor4D const& vec) { return { vec.r, vec.g, vec.b, vec.a }; }

  void AddVertices(std::vector<Graphics::Vertex>& vertexBuffer, aiMesh const* mesh);
  void AddIndices(std::vector<uint32_t>& indices, aiMesh const* mesh);
  void ProcessSubmeshes(std::vector<Graphics::Vertex>& vertexBuffer, std::vector<uint32_t>& indices,
    std::vector<Graphics::Submesh>& submeshes, aiNode* node, aiScene const* scene);
  std::vector<Graphics::Submesh> ProcessMeshes(std::vector<Graphics::Vertex>& vertexBuffer,
    std::vector<uint32_t>& indices, aiNode* node, aiScene const* scene);
}

namespace Graphics::AssetIO
{
  // erm i read through all the flags and these seemed like the best setup? Idk needs some testing
  unsigned MeshConverter::sAssimpImportFlags = aiProcess_CalcTangentSpace | aiProcess_JoinIdenticalVertices | aiProcess_Triangulate
    | aiProcess_RemoveComponent | aiProcess_GenSmoothNormals | aiProcess_ImproveCacheLocality | aiProcess_FixInfacingNormals
    | aiProcess_FindDegenerates | aiProcess_FindInvalidData | aiProcess_SortByPType | aiProcess_CalcTangentSpace
    | aiProcess_OptimizeMeshes | aiProcess_FlipUVs;


  int MeshImportFlags::GetFlags() const {
    int ret{};
    if (!animations) { ret | aiComponent_ANIMATIONS; }
    if (!boneWeights) { ret | aiComponent_BONEWEIGHTS; }
    if (!cameras) { ret | aiComponent_CAMERAS; }
    if (!materials) { ret | aiComponent_MATERIALS; }
    if (!lights) { ret | aiComponent_LIGHTS; }

    return ret;
  }

  MeshConverter::MeshConverter(std::string const& file, MeshImportFlags const& importFlags) : mVertexBuffer{}, mIndices{}, mSubmeshes{}, mStatus { true } {
    Assimp::Importer importer;

    importer.SetPropertyInteger(AI_CONFIG_PP_RVC_FLAGS, importFlags.GetFlags());

    aiScene const* aiScn{ importer.ReadFile(file, sAssimpImportFlags) };
    if (!aiScn || aiScn->mFlags & AI_SCENE_FLAGS_INCOMPLETE || !aiScn->mRootNode) {
      mStatus = false;
      Debug::DebugLogger::GetInstance().LogError("Unable to import model " + file);
      return;
    }

    mSubmeshes = ProcessMeshes(mVertexBuffer, mIndices, aiScn->mRootNode, aiScn);
  }

  std::shared_ptr<MeshSource> MeshConverter::GetMeshSource() const
  {
    return {};
  }

  

} // namespace Graphics::AssetIO


namespace {
  void AddVertices(std::vector<Graphics::Vertex>& vertexBuffer, aiMesh const* mesh)
  {
    vertexBuffer.resize(vertexBuffer.size() + mesh->mNumVertices);
    for (unsigned i{}; i < mesh->mNumVertices; ++i) {
      vertexBuffer[i].position = ToGLMVec3(mesh->mVertices[i]);

      // these 3 should be automatically generated by assimp if not present
      vertexBuffer[i].normal = ToGLMVec3(mesh->mNormals[i]);
      vertexBuffer[i].tangent = ToGLMVec3(mesh->mTangents[i]);
      vertexBuffer[i].bitangent = ToGLMVec3(mesh->mBitangents[i]);
    }

    if (mesh->HasTextureCoords(0)) {
      for (unsigned i{}; i < mesh->mNumVertices; ++i) {
        vertexBuffer[i].texcoord = ToGLMVec2(mesh->mTextureCoords[0][i]);
      }
    }

    if (mesh->HasVertexColors(0)) {
      for (unsigned i{}; i < mesh->mNumVertices; ++i) {
        vertexBuffer[i].texcoord = ToGLMVec4(mesh->mColors[0][i]);
      }
    }
  }

  void AddIndices(std::vector<uint32_t>& indices, aiMesh const* mesh) {
    for (size_t i{}, totalCount{ indices.size() }; i < mesh->mNumFaces; ++i) {
      auto const& face{ mesh->mFaces[i] };
      totalCount += face.mNumIndices;
      indices.reserve(totalCount);
      for (unsigned j{}; j < face.mNumIndices; ++j) {
        indices.emplace_back(face.mIndices[j]);
      }
    }
  }

  void ProcessSubmeshes(std::vector<Graphics::Vertex>& vertexBuffer, std::vector<uint32_t>& indices,
    std::vector<Graphics::Submesh>& submeshes, aiNode* node, aiScene const* scene)
  {
    // now add the submeshes
    for (unsigned i{}; i < node->mNumChildren; ++i) {
      std::vector<uint32_t> subIndices{};
      aiMesh const* mesh{ scene->mMeshes[node->mMeshes[i]] };
      AddVertices(vertexBuffer, mesh);
      AddIndices(indices, mesh);
      AddIndices(subIndices, mesh);
      submeshes.emplace_back(vertexBuffer.size(), indices.size(), mesh->mNumVertices, subIndices.size(), 0, glm::mat4(1.f), subIndices);
    }

    for (unsigned i{}; i < node->mNumChildren; ++i) {
      ProcessSubmeshes(vertexBuffer, indices, submeshes, node->mChildren[i], scene);
    }
  }

  std::vector<Graphics::Submesh> ProcessMeshes(std::vector<Graphics::Vertex>& vertexBuffer,
    std::vector<uint32_t>& indices, aiNode* node, aiScene const* scene) {
    // process base meshes
    for (unsigned i{}; i < node->mNumMeshes; ++i) {
      aiMesh const* mesh{ scene->mMeshes[node->mMeshes[i]] };
      AddVertices(vertexBuffer, mesh);
      AddIndices(indices, mesh);
    }

    std::vector<Graphics::Submesh> submeshes;
    submeshes.reserve(node->mNumChildren);
    for (unsigned i{}; i < node->mNumChildren; ++i) {
      ProcessSubmeshes(vertexBuffer, indices, submeshes, node->mChildren[i], scene);
    }

    return submeshes;
  }
}

#endif  // IMGUI_DISABLE
